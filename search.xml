<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>分布式环境下的UUID生成策略</title>
      <link href="/posts/tech-talker/dist_uuid_gen/"/>
      <url>/posts/tech-talker/dist_uuid_gen/</url>
      <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 <strong>前言</strong></h3><blockquote><p>UUID(Universally Unique Identifier), 通用唯一识别码， 其产生的目的就是为了在分布式的大环境下让每一个独立的有意义的元素都有其唯一的身份识别码，如同我们的身份证号一样。</p></blockquote><h3 id="1-抛砖"><a href="#1-抛砖" class="headerlink" title="1 抛砖"></a>1 <strong>抛砖</strong></h3><h4 id="1-java原生UUID生成方式"><a href="#1-java原生UUID生成方式" class="headerlink" title="1. java原生UUID生成方式"></a>1. java原生UUID生成方式</h4><ul><li><strong>示例</strong><pre><code class="java">String uuid = UUID.randomUUID().toString();System.out.println(uuid);//output: 52f3a858-cd2d-4994-b4f1-9a06839deb45</code></pre></li><li><strong>缺点</strong></li></ul><ol><li>UUID随机生成长度为36位的字符串，太长，占用空间较大，就算去掉<code>-</code>，还是很长</li><li>丑陋，反人类的识别度</li><li>无序，若排序几无可能</li><li>索引效率特别低，入库性能差</li></ol><h4 id="2-mysql数据库自增ID"><a href="#2-mysql数据库自增ID" class="headerlink" title="2. mysql数据库自增ID"></a>2. mysql数据库自增ID</h4><ul><li><strong>示例</strong><br>创建名为uuid的表，结构如下</li></ul><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">field</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">PK</td><td style="text-align:center">char(1)</td></tr></tbody></table><p>然后每次获取id:</p><pre><code class="sql">REPLACE INTO uuid (field) VALUES (&#39;a&#39;);select LAST_INSERT_ID();</code></pre><p>当然，为了提高性能，体现分布式的优势，我们可以采用分库的方式，使用proxy请求不同的分库，如图<br><img src="http://5b0988e595225.cdn.sohucs.com/images/20180518/2ac0cbcc884b487391f412a08020ab7d.png" alt="proxy分库生成uuid"><br>这样一来，DB1生成的ID是1,4,7,10,13….，DB2生成的ID是2,5,8,11,14…..</p><ul><li><strong>缺点</strong><br>ID生成严重依赖mysql，每次生成都需要请求mysql，在高并发环境下，性能不是很好，如果数据库挂掉，会影响业务</li></ul><h3 id="2-引玉"><a href="#2-引玉" class="headerlink" title="2 引玉"></a>2 <strong>引玉</strong></h3><h4 id="1-Twitter的SnowFlake-雪花算法"><a href="#1-Twitter的SnowFlake-雪花算法" class="headerlink" title="1. Twitter的SnowFlake 雪花算法"></a>1. Twitter的SnowFlake 雪花算法</h4><ul><li><strong>概述</strong><br><img src="http://5b0988e595225.cdn.sohucs.com/images/20180518/1af4eb1ec81d4501a757cfdc9ada72d1.jpeg" alt="snowflake data structure"></li></ul><p><code>1位</code>，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0用来记录时间戳（毫秒）。</p><p><code>41位</code>，用来记录时间戳（毫秒）。</p><ul><li style="list-style: none"><input type="checkbox" checked> 可以表示2^41−1个数字，</li><li style="list-style: none"><input type="checkbox" checked> 如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 241−1，减1是因为可表示的数值范围是从0开始算的，而不是1。</li><li style="list-style: none"><input type="checkbox" checked> 也就是说41位可以表示241−1个毫秒的值，转化成单位年则是(241−1)/(1000∗60∗60∗24∗365)=69年<br>10位，用来记录工作机器id。<br>可以部署在210=1024个节点，包括5位datacenterId和5位workerId<br>5位（bit）可以表示的最大正整数是2^5−1=31$，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId<br>12位，序列号，用来记录同毫秒内产生的不同id。<br>12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</li></ul><p><code>10位</code>，用来记录工作机器id。</p><ul><li style="list-style: none"><input type="checkbox" checked> 可以部署在2^10=1024个节点，包括5位<code>datacenterId</code>和5位<code>workerId</code></li><li style="list-style: none"><input type="checkbox" checked> 5位（bit）可以表示的最大正整数是$2^5−1=31$，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</li></ul><p><code>12位</code>，序列号，用来记录同毫秒内产生的不同id。</p><ul><li style="list-style: none"><input type="checkbox" checked> 12位（bit）可以表示的最大正整数是$2^{12}−1=4095$，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间戳（毫秒)内产生的4095个ID序号</li></ul><ul><li><strong>SHOW THE CODE</strong><br>…</li><li><strong>解惑</strong><pre><code>// 时间戳差值导致ID位数变化double v = Math.pow(10, 17);long val = new Double(v).longValue();long year =1000 * 60 * 60 * 24 * 365L;System.out.println((double)(val &gt;&gt; 22) / year);</code></pre></li></ul><h4 id="2-Redis生成自增"><a href="#2-Redis生成自增" class="headerlink" title="2. Redis生成自增"></a>2. Redis生成自增</h4>]]></content>
      
      <categories>
          
          <category> 谈技论术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> middle-ware </tag>
            
            <tag> distribution </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建Blog拾遗及相关资料归档</title>
      <link href="/posts/tech-talker/pin/"/>
      <url>/posts/tech-talker/pin/</url>
      <content type="html"><![CDATA[<h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>Ubuntu搭建Node.js环境，我只记两点：</p><ul><li>官网下载最新node版本<br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node官网</a></li><li><p>使用npm时出现：</p><pre><code class="shell">Error: /usr/bin/env: node:没有那个文件或目录</code></pre><blockquote><p>cause: ubuntu避免包冲突，会将nodejs操作命令改为nodejs，而不是node</p></blockquote><p>执行命令：</p><pre><code class="shell">sudo ln -s /usr/bin/nodejs /usr/bin/node</code></pre></li></ul><h4 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h4><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>本blog使用的主题为<code>material</code>，也许你可能在执行<code>hexo g</code>的时候可能会遇到如下错误：<br><code>Internal watch failed: watch ENOSPC</code><br>解决办法，执行命令：  </p><pre><code class="shell">echo fs.inotify.max_user_watches=582222 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</code></pre><p>然后再执行<code>hexo g</code>.</p><h5 id="相关资料归档"><a href="#相关资料归档" class="headerlink" title="相关资料归档"></a>相关资料归档</h5><ul><li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material-theme-github</a></li><li><a href="https://material.viosey.com/docs/#/start" target="_blank" rel="noopener">theme-doc</a></li><li><a href="https://material.io/tools/icons/" target="_blank" rel="noopener">icons</a>, 直接复制icon名称到主题<code>_config.yml</code>相应位置中<pre><code class="yaml">pages:        关于我:            link: &quot;/aboutMe&quot;            icon: round-fingerprint-24px.svg            divider: false</code></pre></li><li>图片压缩，小白玩法： <a href="http://www.yasuotu.com/" target="_blank" rel="noopener">compress-image</a>  </li><li><blockquote><p>感谢教程：<a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="noopener">GitHub+Hexo搭建个人Blog</a></p></blockquote></li></ul>]]></content>
      
      <categories>
          
          <category> 谈技论术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>诞生</title>
      <link href="/posts/self-whisper/origin/"/>
      <url>/posts/self-whisper/origin/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>有时候，遥望星空，你可能会惊奇地发现：在某一星区，出现了一颗从来没有见过的明亮星星！<br>然而仅仅过了几个月甚至几天，它又渐渐消失了。<br>—— Nova, 新星  </p><ul><li>没什么别的，就是单纯的很喜欢这个单词。</li><li>年少时在warcraft 3中，操纵litch的技能N(Frost Nova)，第一次接触到这个词。</li><li>现在想起来，所有被称作Nova的游戏技能，其实际效果真的很契合这个单词的本意：<br><code>散发着耀眼的光芒，然后消逝</code>。</li><li>当然，这个词的发音<code>/&#39;noʊvə/</code>真的很顺口…</li></ul></blockquote><h4 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h4><p><strong> 总是开发着无聊的接口，乏味的系统，一直对能描绘出夺人眼球的美丽脸庞这种技能蠢蠢欲动，<br>但当我面对那如abyss般深不见底的恐怖<code>前端</code>的时候，我想我现在还没有勇气去踏入这条我的不归路。</strong></p><p>作为一只后端程序猿，从没有放弃成为一个全栈开发工程师，挣扎在模板开发引擎的泥潭中，嘴上骂着脏字，手上还不得不敲着<code>${name}</code>和<code>th:replace</code> …  </p><h4 id="波折"><a href="#波折" class="headerlink" title="波折"></a>波折</h4><p>为了使用<code>npm</code>，装个<code>node.js</code>都不能成功时，我更加坚信怀疑前端这个小姐姐我爱不上了…</p><p>而且我竟然显现出了可憎的举措：对网上咒骂<code>js</code>的言论啧啧称赞——得不到我就恨！</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>然后心里的种子在多次的惊鸿一瞥之后，开始生根发芽，直到我看到了public formal version…  </p><blockquote><p>我决定！启动。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 自言自语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> me </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
